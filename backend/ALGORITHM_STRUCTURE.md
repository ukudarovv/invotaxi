# Структура алгоритма распределения заказов

## Обзор системы

В системе реализовано два алгоритма распределения заказов:

1. **Базовый алгоритм** (`DispatchEngine`) - простая система назначения
2. **Продвинутый алгоритм** (`MatchingService`) - многофакторный скоринг с офферами

---

## 1. Базовый алгоритм (DispatchEngine)

### 1.1 Архитектура

```
Триггер назначения заказа
    ↓
Проверка статуса заказа (должен быть ACTIVE_QUEUE)
    ↓
Поиск кандидатов (_find_candidates)
    ↓
Сортировка по приоритету (_calculate_priority)
    ↓
Выбор лучшего кандидата (первый в отсортированном списке)
    ↓
Назначение водителя на заказ
```

### 1.2 Метод `assign_order(order: Order)`

**Входные данные:**
- `order` - заказ со статусом `ACTIVE_QUEUE`

**Шаги выполнения:**

1. **Проверка статуса заказа**
   - Если статус не `ACTIVE_QUEUE` → возврат ошибки

2. **Сброс дневных счетчиков**
   - Проверка наступления нового дня
   - Очистка счетчиков заказов по водителям

3. **Поиск кандидатов** (`_find_candidates`)
   - Фильтрация по критериям

4. **Проверка наличия кандидатов**
   - Если кандидатов нет → возврат ошибки с диагностикой

5. **Сортировка по приоритету** (`_calculate_priority`)
   - Вычисление приоритета для каждого кандидата

6. **Выбор водителя**
   - Берется первый водитель из отсортированного списка

7. **Обновление счетчиков**
   - Инкремент счетчика заказов для выбранного водителя

8. **Возврат результата**
   - `AssignmentResult` с ID водителя и причиной назначения

### 1.3 Метод `_find_candidates(order: Order)`

**Критерии фильтрации:**

1. **Базовые фильтры:**
   - `is_online = True` - водитель должен быть онлайн

2. **ЖЕСТКИЙ ФИЛЬТР: Район должен совпадать**
   - Определяется район заказа через `order.pickup_region` (по координатам pickup)
   - Fallback на `order.passenger.region` если район не определен по координатам
   - `driver.region == order.pickup_region` - **обязательное условие**
   - Водители без заполненного `region` исключаются

3. **Исключение занятых водителей:**
   - Статус `ON_TRIP` - в поездке
   - Статус `ENROUTE_TO_PICKUP` - едет к подаче
   - Статус `OFFERED` - получил предложение
   - Статус `PAUSED` - на перерыве

4. **Проверка вместимости:**
   - `driver.capacity >= order.seats_needed`

5. **Синхронизация статусов:**
   - Если `is_online=True`, но статус `OFFLINE` → исправление на `ONLINE_IDLE`

**Логирование:**
- Район заказа (pickup_region)
- Количество онлайн водителей
- Количество кандидатов до фильтрации по району
- Количество кандидатов после фильтрации по району
- Количество отфильтрованных по каждому критерию (район, вместимость, статус)

### 1.4 Метод `_calculate_priority(driver, order, passenger)`

**Факторы приоритета (кортеж для сортировки):**

**ВАЖНО:** Район уже отфильтрован как жесткое условие в `_find_candidates()`, поэтому здесь учитываются только:

1. **Количество заказов за сегодня** (fairness)
   - Меньше заказов = выше приоритет
   - Баланс распределения нагрузки

2. **Расстояние до точки забора** (км)
   - Географическое расстояние от позиции водителя до pickup точки
   - Использует `Geo.calculate_distance()`

**Сортировка:**
- По возрастанию кортежа (0, 2.5) < (1, 3.0) < (0, 1.0)

---

## 2. Продвинутый алгоритм (MatchingService)

### 2.1 Архитектура Pipeline

```
Триггер (создан заказ / освободился водитель)
    ↓
A. Проверка статуса заказа
    ↓
B. Предварительная фильтрация (hard constraints)
    ↓
C. Top-K по ETA (быстродействие)
    ↓
D. Многофакторный скоринг (soft constraints)
    ↓
E. Выбор лучшего кандидата
    ↓
F. Отправка оффера + таймер
    ↓
G. Обработка ответа (принят/отклонен/таймаут)
```

### 2.2 Метод `assign_order(order: Order)`

**Входные данные:**
- `order` - заказ со статусом `CREATED`, `MATCHING` или `ACTIVE_QUEUE`

**Шаги выполнения:**

#### Шаг A: Проверка и подготовка
1. Проверка статуса заказа
   - Допустимые статусы: `CREATED`, `MATCHING`, `ACTIVE_QUEUE`
   - Иначе → возврат ошибки

2. Перевод в статус `MATCHING`
   - Если заказ не в статусе `MATCHING`, перевод с комментарием

#### Шаг B: Предварительная фильтрация
- Вызов `_filter_candidates(order)`
- Если кандидатов нет → переход к расширению поиска (`_expand_search`)

#### Шаг C: Top-K по ETA
- Вызов `_get_top_k_by_eta(candidates, order, k_candidates)`
- Выбор до K лучших кандидатов по времени подачи
- Если кандидатов нет → возврат ошибки

#### Шаг D: Скоринг
- Для каждого кандидата из Top-K:
  - Вызов `_score_candidate(order, driver)`
  - Получение `CandidateScore` с cost и деталями
- Если ни один кандидат не получил score → возврат ошибки

#### Шаг E: Выбор лучшего
- Сортировка по `cost` (меньше = лучше)
- Выбор кандидата с минимальным cost

#### Шаг F: Отправка оффера
- Вызов `_send_offer(order, best_candidate)`
- Создание `OrderOffer` с таймером
- Обновление статусов заказа и водителя

### 2.3 Метод `_filter_candidates(order: Order)`

**Hard constraints (обязательные условия):**

1. **Базовые фильтры через QuerySet:**
   ```python
   Q(
       is_online=True,
       status__in=[DriverStatus.ONLINE_IDLE, DriverStatus.PAUSED],
       capacity__gte=order.seats_needed
   )
   ```

2. **ЖЕСТКИЙ ФИЛЬТР: Район должен совпадать**
   - Определяется район заказа через `order.pickup_region` (по координатам pickup)
   - Fallback на `order.passenger.region` если район не определен
   - `Q(region=order.pickup_region)` - **обязательное условие в QuerySet**
   - Водители без заполненного `region` исключаются

3. **Дополнительные проверки в цикле:**
   - **Рейтинг:** `driver.rating >= config.min_rating` (по умолчанию 4.0)
   - **GPS координаты:** должны быть установлены (`current_lat`, `current_lon`)
   - **Свежесть GPS:** последнее обновление не старше 5 минут
   - **Лимит офферов:** `offers_last_60min < config.max_offers_per_hour` (по умолчанию 20)

**Результат:**
- Список `Driver` объектов, прошедших все фильтры
- Логирование количества кандидатов до/после фильтрации по району

### 2.4 Метод `_get_top_k_by_eta(candidates, order, k)`

**Цель:**
- Быстро отсеять кандидатов с большим ETA
- Оставить только K лучших по времени подачи

**Алгоритм:**

1. Для каждого кандидата:
   - Расчет ETA через `dispatch_engine.calculate_eta(driver, order)`
   - Если ETA > `config.eta_max_seconds` (по умолчанию 720 сек = 12 мин) → пропуск
   - Сохранение пары (driver, eta_seconds)

2. Сортировка по ETA (возрастание)

3. Выбор первых K кандидатов

**Результат:**
- Список из K водителей с наименьшим ETA

### 2.5 Метод `_score_candidate(order, driver)`

**Цель:**
- Вычислить общий cost (меньше = лучше) на основе множества факторов
- Все метрики нормализуются в диапазон [0..1]

**Метрики и их нормализация:**

1. **ETA (время подачи)**
   ```python
   eta_norm = min(eta_seconds / config.eta_max_seconds, 1.0)
   ```
   - Чем меньше время подачи, тем лучше

2. **Deadhead (холостой пробег)**
   ```python
   deadhead_norm = min(distance_km / max_distance_km, 1.0)  # max = 20 км
   ```
   - Расстояние от водителя до точки забора

3. **Reject risk (риск отказа)**
   ```python
   reject_norm = 1.0 - stats.acceptance_rate
   ```
   - Вероятность отклонения оффера водителем
   - Высокий acceptance_rate → низкий reject_norm

4. **Cancel risk (риск отмены)**
   ```python
   cancel_norm = stats.cancel_rate
   ```
   - Вероятность отмены заказа после принятия

5. **Fairness (справедливость)**
   ```python
   median_orders = _get_median_orders_last_hour()
   fairness_diff = stats.orders_last_60min - median_orders
   fairness_norm = min(abs(fairness_diff) / 5.0, 1.0)
   ```
   - Штраф за отклонение от медианы заказов за час
   - Баланс распределения между водителями

6. **Zone balancing (баланс зон)**
   ```python
   zone_norm = 0.0  # TODO: реализовать heatmap
   ```
   - Штраф за "высасывание" водителей из зоны спроса
   - Пока не реализовано

7. **Quality (качество)**
   ```python
   if driver.rating < 4.5:
       quality_norm = (4.5 - driver.rating) / 1.5
   else:
       quality_norm = 0.0
   ```
   - Штраф за низкий рейтинг

**Расчет итогового cost:**

```python
cost = (
    config.w_eta * eta_norm +
    config.w_deadhead * deadhead_norm +
    config.w_reject * reject_norm +
    config.w_cancel * cancel_norm +
    config.w_fairness * fairness_norm +
    config.w_zone * zone_norm +
    config.w_quality * quality_norm
)
```

**Веса по умолчанию:**
- `w_eta = 0.4` (40%) - время подачи (самый важный)
- `w_reject = 0.2` (20%) - риск отказа
- `w_deadhead = 0.15` (15%) - холостой пробег
- `w_cancel = 0.15` (15%) - риск отмены
- `w_fairness = 0.05` (5%) - справедливость
- `w_zone = 0.03` (3%) - баланс зон
- `w_quality = 0.02` (2%) - качество

**Результат:**
- `CandidateScore` объект с:
  - `driver` - водитель
  - `cost` - итоговый cost (float)
  - `details` - словарь со всеми нормализованными метриками

### 2.6 Метод `_send_offer(order, candidate_score)`

**Цель:**
- Создать оффер водителю с таймером
- Обновить статусы заказа и водителя

**Шаги:**

1. **Проверка активных офферов**
   - Если у заказа уже есть активный оффер → возврат ошибки

2. **Создание OrderOffer**
   - `order` - заказ
   - `driver` - водитель
   - `status = 'pending'`
   - `expires_at = now() + config.offer_timeout_seconds` (по умолчанию 15 сек)
   - `eta_seconds` - расчетное время подачи
   - `distance_km` - расстояние до подачи
   - `cost_score` - итоговый cost
   - `selection_reason` - текстовое объяснение выбора

3. **Обновление статуса заказа**
   - Перевод в `OrderStatus.OFFERED`
   - Комментарий с именем водителя

4. **Обновление статуса водителя**
   - `driver.status = DriverStatus.OFFERED`

5. **Обновление статистики**
   - Инкремент `offers_last_60min` у водителя

6. **TODO: Отправка уведомления**
   - WebSocket или push-уведомление водителю

**Результат:**
- Словарь с информацией об оффере (offer_id, driver_id, eta_seconds, cost_score и т.д.)

### 2.7 Метод `_expand_search(order)`

**Цель:**
- Расширить поиск при отсутствии кандидатов
- Увеличить максимальный ETA и радиус поиска **ВНУТРИ ТОГО ЖЕ РАЙОНА**

**ВАЖНО:** Расширение поиска НЕ расширяет на другие районы. Район остается жестким условием.

**Алгоритм:**

1. Проверка района заказа
   - Получение `order.pickup_region`
   - Если район не определен → возврат ошибки

2. Увеличение `eta_max_seconds` (но район остается тем же)
   ```python
   expanded_eta_max = original_eta_max * config.expand_eta_multiplier  # по умолчанию 1.5
   ```

3. Временное изменение конфигурации
   - Сохранение старой конфигурации
   - Установка нового `eta_max_seconds`
   - **Район НЕ изменяется**, так как `_filter_candidates()` использует `order.pickup_region`

4. Повторный поиск кандидатов
   - Вызов `_filter_candidates(order)` (район останется тем же)
   - Если кандидатов нет → возврат ошибки с указанием района

5. Продолжение стандартного pipeline
   - Top-K, скоринг, выбор, оффер

6. Восстановление конфигурации

**Результат:**
- Результат стандартного pipeline или ошибка с указанием, что в районе нет водителей

### 2.8 Обработка ответов на офферы

#### `handle_offer_accepted(offer)`

**Шаги:**
1. Проверка валидности оффера (статус `pending`, не истек)
2. Проверка, что заказ еще не назначен
3. Обновление оффера: `status = 'accepted'`, `responded_at = now()`
4. Назначение водителя на заказ: `order.driver = offer.driver`
5. Перевод заказа в статус `ASSIGNED`
6. Обновление статуса водителя: `ENROUTE_TO_PICKUP`
7. Обновление статистики: инкремент `orders_last_60min`, пересчет `acceptance_rate`
8. Отмена других активных офферов для этого заказа
9. Возврат других водителей в статус `ONLINE_IDLE`

#### `handle_offer_declined(offer)`

**Шаги:**
1. Проверка валидности оффера
2. Обновление оффера: `status = 'declined'`, `responded_at = now()`
3. Обновление статистики: инкремент `rejections_count`, пересчет `acceptance_rate`
4. Возврат водителя в статус `ONLINE_IDLE`
5. Перевод заказа обратно в `MATCHING`
6. Повторный вызов `assign_order(order)` для поиска другого водителя

#### `handle_offer_timeout(offer)`

**Шаги:**
1. Проверка, что оффер истек (`is_expired = True`)
2. Обновление оффера: `status = 'timeout'`, `responded_at = now()`
3. Обновление статистики (как при отклонении)
4. Возврат водителя в статус `ONLINE_IDLE`
5. Перевод заказа в `MATCHING`
6. Повторный вызов `assign_order(order)`

---

## 3. Конфигурация алгоритма (DispatchConfig)

### 3.1 Параметры фильтрации

- `eta_max_seconds` (по умолчанию 720) - максимальный ETA до подачи
- `k_candidates` (по умолчанию 50) - количество кандидатов для скоринга (Top-K)
- `offer_timeout_seconds` (по умолчанию 15) - таймаут оффера в секундах

### 3.2 Веса скоринга

- `w_eta` (0.4) - вес времени подачи
- `w_deadhead` (0.15) - вес холостого пробега
- `w_reject` (0.2) - вес риска отказа
- `w_cancel` (0.15) - вес риска отмены
- `w_fairness` (0.05) - вес справедливости
- `w_zone` (0.03) - вес баланса зон
- `w_quality` (0.02) - вес качества

### 3.3 Пороги и лимиты

- `min_rating` (4.0) - минимальный рейтинг водителя
- `max_offers_per_hour` (20) - максимум офферов водителю за час

### 3.4 Правила расширения поиска

- `expand_search_after_seconds` (30) - через сколько секунд расширить поиск
- `expand_eta_multiplier` (1.5) - во сколько раз увеличить максимальный ETA

---

## 4. Вспомогательные сервисы

### 4.1 DispatchEngine.calculate_eta(driver, order)

**Цель:**
- Расчет времени прибытия водителя к точке забора

**Метод:**
1. Расчет маршрута через `calculate_driver_route(driver, order)`
2. Использование OSRM API для расчета по дорогам
3. Fallback на прямую линию, если OSRM недоступен

**Результат:**
- Словарь с `eta`, `distance_km`, `duration_seconds`, `duration_minutes`

### 4.2 DispatchEngine.calculate_route(lat1, lon1, lat2, lon2)

**Алгоритм:**
1. Попытка подключения к OSRM серверам (HTTP/HTTPS)
2. Если успешно → возврат маршрута по дорогам
3. Если недоступно → fallback на `_calculate_straight_line_route()`

**Результат:**
- Словарь с `route` (координаты), `distance_m`, `distance_km`, `duration_seconds`

---

## 5. Статусы и состояния

### 5.1 Статусы заказа

- `CREATED` - создан
- `MATCHING` - поиск водителя
- `ACTIVE_QUEUE` - в очереди на назначение
- `OFFERED` - предложение отправлено водителю
- `ASSIGNED` - водитель назначен
- `DRIVER_EN_ROUTE` - водитель в пути к подаче
- `ARRIVED_WAITING` - водитель прибыл, ожидание пассажира
- `RIDE_ONGOING` - поездка началась
- `COMPLETED` - завершено
- `CANCELLED` - отменено

### 5.2 Статусы водителя

- `OFFLINE` - водитель офлайн
- `ONLINE_IDLE` - онлайн, свободен
- `OFFERED` - получил предложение (идет таймер)
- `ENROUTE_TO_PICKUP` - принял заказ, едет к подаче
- `ON_TRIP` - в поездке
- `PAUSED` - перерыв/блокировка

### 5.3 Статусы оффера (OrderOffer)

- `pending` - ожидает ответа
- `accepted` - принят водителем
- `declined` - отклонен водителем
- `timeout` - истек по таймеру

---

## 6. Статистика водителей (DriverStatistics)

### 6.1 Метрики

- `acceptance_rate` - процент принятых офферов (0.0 - 1.0)
- `cancel_rate` - процент отмененных заказов (0.0 - 1.0)
- `offers_last_60min` - количество офферов за последний час
- `orders_last_60min` - количество принятых заказов за последний час
- `rejections_count` - общее количество отказов

### 6.2 Использование в скоринге

- `acceptance_rate` → `reject_norm = 1.0 - acceptance_rate`
- `cancel_rate` → `cancel_norm = cancel_rate`
- `orders_last_60min` → расчет `fairness_norm`
- `offers_last_60min` → проверка лимита офферов

---

## 7. Сравнение алгоритмов

| Критерий | Базовый (DispatchEngine) | Продвинутый (MatchingService) |
|----------|-------------------------|-------------------------------|
| **Сложность** | Простой | Сложный, многофакторный |
| **Скоринг** | Простой приоритет (регион, fairness, расстояние) | Многофакторный cost (7 метрик) |
| **Офферы** | Нет (прямое назначение) | Да (с таймерами) |
| **Расширение поиска** | Нет | Да |
| **Статистика** | Только дневные счетчики | Детальная статистика водителей |
| **Производительность** | Быстрее | Медленнее (больше вычислений) |
| **Точность** | Базовая | Высокая |

---

## 8. Рекомендации по использованию

### 8.1 Когда использовать базовый алгоритм

- Небольшое количество водителей (< 100)
- Простая логика распределения достаточна
- Нужна максимальная скорость обработки
- Нет необходимости в сложном скоринге

### 8.2 Когда использовать продвинутый алгоритм

- Большое количество водителей (> 100)
- Важна оптимизация множества факторов одновременно
- Нужен контроль качества (рейтинги, acceptance rate)
- Важна справедливость распределения
- Нужна система офферов с таймерами

---

## 9. Мониторинг и оптимизация

### 9.1 Метрики для отслеживания

1. **Время назначения**
   - Средний ETA подачи
   - Время от создания заказа до назначения

2. **Acceptance rate**
   - Процент принятых офферов
   - Должен быть > 80%

3. **Cancel rate**
   - Процент отмен после принятия
   - Должен быть < 10%

4. **Справедливость**
   - Распределение заказов между водителями
   - Коэффициент Джини (должен быть < 0.3)

5. **Производительность**
   - Время выполнения `assign_order()`
   - Должно быть < 1 секунды

### 9.2 Тюнинг весов

**Если важнее скорость подачи:**
- Увеличить `w_eta` до 0.5-0.6
- Уменьшить `w_fairness`, `w_zone`

**Если важнее экономика:**
- Увеличить `w_deadhead` до 0.25
- Уменьшить `w_eta`

**Если много отказов:**
- Увеличить `w_reject` до 0.3
- Проверить статистику водителей

**Если важна справедливость:**
- Увеличить `w_fairness` до 0.1-0.15

---

## 10. Потенциальные улучшения

### 10.1 Batch-matching
- Одновременное назначение нескольких заказов
- Использование венгерского алгоритма или min-cost max-flow

### 10.2 Zone balancing
- Heatmap спроса и предложения
- Расчет `zone_norm` на основе плотности водителей в зонах

### 10.3 Машинное обучение
- Предсказание acceptance rate через ML модель
- Оптимизация весов через reinforcement learning

### 10.4 Антифрод GPS
- Проверка на GPS spoofing
- Валидация резких прыжков координат
- Проверка неподвижности при "движении"

### 10.5 Кеширование
- Кеширование расчета ETA
- Кеширование медианы заказов за час
- Redis для счетчиков и статистики

---

## 11. Примеры использования

### 11.1 Базовый алгоритм

```python
from dispatch.services import DispatchEngine
from orders.models import Order

engine = DispatchEngine()
result = engine.assign_order(order)

if result.driver_id:
    print(f"Назначен водитель {result.driver_id}: {result.reason}")
else:
    print(f"Ошибка: {result.rejection_reason}")
```

### 11.2 Продвинутый алгоритм

```python
from dispatch.matching_service import MatchingService
from orders.models import Order

matching_service = MatchingService()
result = matching_service.assign_order(order)

if result['success']:
    print(f"Оффер отправлен водителю {result['driver_id']}")
    print(f"ETA: {result['eta_seconds']} секунд")
    print(f"Cost score: {result['cost_score']}")
else:
    print(f"Ошибка: {result['error']}")
```

### 11.3 Обработка оффера

```python
from dispatch.matching_service import MatchingService
from orders.models import OrderOffer

matching_service = MatchingService()
offer = OrderOffer.objects.get(id=offer_id)

# Принятие
result = matching_service.handle_offer_accepted(offer)

# Отклонение
result = matching_service.handle_offer_declined(offer)

# Таймаут
result = matching_service.handle_offer_timeout(offer)
```

---

## Заключение

Алгоритм распределения заказов представляет собой многоуровневую систему с двумя режимами работы: простым и продвинутым. Базовый алгоритм подходит для простых случаев, а продвинутый алгоритм обеспечивает оптимизацию множества факторов одновременно через многофакторный скоринг и систему офферов с таймерами.

Система проектирована с учетом масштабируемости, мониторинга и возможности тюнинга параметров под конкретные бизнес-требования.
